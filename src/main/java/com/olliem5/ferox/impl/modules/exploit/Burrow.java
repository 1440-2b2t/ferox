package com.olliem5.ferox.impl.modules.exploit;

import com.mojang.realmsclient.gui.ChatFormatting;
import com.olliem5.ferox.api.module.Category;
import com.olliem5.ferox.api.module.FeroxModule;
import com.olliem5.ferox.api.module.Module;
import com.olliem5.ferox.api.setting.NumberSetting;
import com.olliem5.ferox.api.setting.Setting;
import com.olliem5.ferox.api.util.client.MessageUtil;
import com.olliem5.ferox.api.util.player.InventoryUtil;
import com.olliem5.ferox.api.util.player.PlayerUtil;
import com.olliem5.ferox.api.util.render.draw.RenderUtil;
import com.olliem5.ferox.api.util.world.PlaceUtil;
import com.olliem5.pace.annotation.PaceHandler;
import net.minecraft.block.Block;
import net.minecraft.init.Blocks;
import net.minecraft.item.Item;
import net.minecraft.network.play.client.CPacketPlayer;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.Vec3d;
import net.minecraftforge.client.event.RenderWorldLastEvent;
import net.minecraftforge.common.ForgeHooks;
import org.lwjgl.opengl.GL11;

import java.awt.*;

/**
 * @author olliem5
 */

@FeroxModule(name = "Burrow", description = "Places a block inside of you", category = Category.Exploit)
public final class Burrow extends Module {
    public static final Setting<BlockModes> blockMode = new Setting<>("Block", "The block to burrow with", BlockModes.Obsidian);
    public static final Setting<Boolean> centerPlayer = new Setting<>("Center Player", "Centers the player before burrowing", true);
    public static final Setting<Boolean> instaBurrow = new Setting<>("Instant", "You don't have to jump!", false);
    private static final Setting<Boolean> disableAferPlace = new Setting<>("Disable after Place", "Disables the module after a place", true);

    public static final Setting<Boolean> renderPlace = new Setting<>("Render", "Allows the placements to be rendered", true);
    public static final Setting<RenderModes> renderMode = new Setting<>(renderPlace, "Render Mode", "The type of box to render", RenderModes.Full);
    public static final NumberSetting<Double> outlineWidth = new NumberSetting<>(renderPlace, "Outline Width", "The width of the outline", 1.0, 2.0, 5.0, 1);
    public static final Setting<Color> renderColour = new Setting<>(renderPlace, "Render Colour", "The colour for the placements", new Color(57, 221, 162, 237));

    public Burrow() {
        this.addSettings(
                blockMode,
                centerPlayer,
                instaBurrow,
                disableAferPlace,
                renderPlace
        );
    }

    private int obsidianSlot;
    private int enderChestSlot;

    private float oldTickLength;

    private Vec3d center = Vec3d.ZERO;
    private BlockPos playerPos = null;

    @Override
    public void onEnable() {
        if (nullCheck()) return;

        obsidianSlot = InventoryUtil.getHotbarBlockSlot(Blocks.OBSIDIAN);
        enderChestSlot = InventoryUtil.getHotbarBlockSlot(Blocks.ENDER_CHEST);

        oldTickLength = mc.timer.tickLength;

        if (getBlockSlot() == -1) {
            MessageUtil.sendClientMessage("No " + getBlockText() + ", " + ChatFormatting.RED + "Disabling!");
            this.disable();
        } else {
            playerPos = new BlockPos(mc.player.posX, mc.player.posY, mc.player.posZ);

            if (mc.world.getBlockState(playerPos).getBlock().isReplaceable(mc.world, playerPos)) {
                if (centerPlayer.getValue()) {
                    mc.player.motionX = 0.0;
                    mc.player.motionZ = 0.0;

                    center = PlayerUtil.getCenter(mc.player.posX, mc.player.posY, mc.player.posZ);

                    mc.player.connection.sendPacket(new CPacketPlayer.Position(center.x, center.y, center.z, true));
                    mc.player.setPosition(center.x, center.y, center.z);
                }

                if (instaBurrow.getValue()) {
                    mc.timer.tickLength = 1.0f;
                }

                if (mc.player.onGround) {
                    mc.player.motionY = 0.42;

                    ForgeHooks.onLivingJump(mc.player);
                }
            }
        }
    }

    @Override
    public void onDisable() {
        if (nullCheck()) return;

        center = Vec3d.ZERO;
        playerPos = null;
        mc.timer.tickLength = oldTickLength;
    }

    public void onUpdate() {
        if (nullCheck()) return;

        if (mc.player.posY > playerPos.getY() + 1.2) {
            int oldInventorySlot = mc.player.inventory.currentItem;

            if (getBlockSlot() != -1) {
                mc.player.inventory.currentItem = getBlockSlot();
            }

            if (mc.player.getHeldItemMainhand().getItem() == Item.getItemFromBlock(getBlockBlock())) {
                PlaceUtil.placeBlock(playerPos);
            }

            mc.player.inventory.currentItem = oldInventorySlot;

            mc.player.jump();

            if (disableAferPlace.getValue()) {
                this.toggle();
            } else {
                mc.timer.tickLength = oldTickLength;
            }
        }
    }

    private String getBlockText() {
        switch (blockMode.getValue()) {
            case Obsidian:
                return "Obsidian";
            case EnderChest:
                return "Ender Chests";
        }

        return "Obsidian";
    }

    private int getBlockSlot() {
        switch (blockMode.getValue()) {
            case Obsidian:
                return obsidianSlot;
            case EnderChest:
                return enderChestSlot;
        }

        return obsidianSlot;
    }

    private Block getBlockBlock() {
        switch (blockMode.getValue()) {
            case Obsidian:
                return Blocks.OBSIDIAN;
            case EnderChest:
                return Blocks.ENDER_CHEST;
        }

        return Blocks.OBSIDIAN;
    }

    @PaceHandler
    public void onRenderWorldLast(RenderWorldLastEvent event) {
        if (nullCheck()) return;

        if (renderPlace.getValue() && playerPos != null) {
            GL11.glLineWidth(outlineWidth.getValue().floatValue());

            RenderUtil.draw(playerPos, renderMode.getValue() != RenderModes.Outline, renderMode.getValue() != RenderModes.Box, 0, 0, renderColour.getValue());
        }
    }

    public enum BlockModes {
        Obsidian,
        EnderChest
    }

    public enum RenderModes {
        Box,
        Outline,
        Full
    }
}
